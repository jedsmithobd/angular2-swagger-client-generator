import { Injectable } from '@angular/core';
import { Http, Response, Headers, URLSearchParams } from '@angular/http';
import { {{#definitions}}{{name}}{{^last}}, {{/last}}{{/definitions}} } from './models';
import 'rxjs/Rx';

export { {{#definitions}}{{name}}{{^last}}, {{/last}}{{/definitions}} };

@Injectable()
/**
 * Created with angular2-swagger-client-generator v{{&version}}
 */
export class ApiClientService {
  domain:string;
  
  constructor(public http: Http){
    {{#domain}}
    this.domain = '{{&.}}';
    {{/domain}}
    {{^domain}}
    this.domain = '';
    {{/domain}}
  }
  
  private urlParamifyObject (paramObject: any): URLSearchParams {
    let params: URLSearchParams = new URLSearchParams();
    for (var param in paramObject) {
      if(paramObject.hasOwnProperty(param) && paramObject[param]) {
        params.set(param, paramObject[param]);
      }
    }
    
    return params;
  } 
  /*
	constructor(public http: Http, options?: any) {
		var domain = (typeof options === 'object') ? options.domain : options;
		this.domain = typeof(domain) === 'string' ? domain : '{{&domain}}';
		
		if(this.domain.length === 0) {
			throw new Error('Domain parameter must be specified as a string.');
		}
		
		{{#isSecure}}
			this.token = (typeof options === 'object') ? (options.token ? options.token : {}) : {};
		{{/isSecure}}
	}
  */


{{#methods}}
	/**
	{{#summaryLines}}
  * {{&.}}
  {{/summaryLines}}
  *
	* @method
	* @name {{&methodName}}
	{{#parameters}}
	{{^isSingleton}}* @param {{=<% %>=}}{<%&type%>}<%={{ }}=%> {{&camelCaseName}} - {{&description}}{{/isSingleton}}
	{{/parameters}}
	* 
	*/
	public {{&methodName}}({{#parameters}}{{&camelCaseName}}{{#typescriptType}}: {{typescriptType}}{{/typescriptType}}{{^last}}, {{/last}}{{/parameters}}) {
		let payload = {};	
		let queryParameters = {};
		let headers = new Headers();
		headers.append('Content-Type', 'application/json');
		
{{#parameters}}
			{{#isQueryParameter}}
			  {{#isSingleton}}
		queryParameters['{{&name}}'] = '{{&singleton}}';
        {{/isSingleton}}
      
			  {{^isSingleton}}
			    {{#isPatternType}}
		Object.keys(parameters).forEach(function(parameterName) {
			if(new RegExp('{{&pattern}}').test(parameterName)){
				queryParameters[parameterName] = parameters[parameterName];
			}
		});
          {{/isPatternType}}
			    {{^isPatternType}}
		if({{&camelCaseName}} !== undefined){
			queryParameters['{{&name}}'] = {{&camelCaseName}};
		}
          {{/isPatternType}}
        {{/isSingleton}}
			{{/isQueryParameter}}
			
			{{#isHeaderParameter}}
			  {{#isSingleton}}
		headers.append('{{&name}}', '{{&singleton}}');
        {{/isSingleton}}
        {{^isSingleton}}
		if({{&camelCaseName}} !== undefined){
			headers.append('{{&name}}', {{&camelCaseName}});
		}
        {{/isSingleton}}
			{{/isHeaderParameter}}
			{{#isBodyParameter}}
		payload['{{&name}}'] = {{&camelCaseName}};
			{{/isBodyParameter}}
			{{#isFormParameter}}
			  {{#isSingleton}}
		queryParameters['{{&name}}'] = '{{&singleton}}';
        {{/isSingleton}}
        {{^isSingleton}}
		if({{&camelCaseName}} !== undefined){
			queryParameters['{{&name}}'] = {{&camelCaseName}};
		}
			  {{/isSingleton}}
			{{/isFormParameter}}
{{/parameters}}		
		let uri = `{{&backTickPath}}`;
	  
		return this.http
			.{{angular2httpMethod}}(this.domain + uri{{#hasPayload}}, {{#bodyParameter}}JSON.stringify(payload['{{&bodyParameter.camelCaseName}}']){{/bodyParameter}}{{^bodyParameter}}''{{/bodyParameter}}{{/hasPayload}}, 
            { 
                headers: headers, 
                search: this.urlParamifyObject(queryParameters) 
            })
			.map((res: Response) => {
        return res;
      });
	}
	
{{/methods}}

}
